

开启CSS时钟安全系统（在 NMI 的处理程序中必须通过设置时钟中断寄存器 (RCC_CIR) 里的 CSSC 位来清除 CSS 中断。）
启动时钟安全系统CSS：
RCC_ClockSecuritySystemCmd(ENABLE); (NMI中断是不可屏蔽的！)
外部振荡器实现时，产生中断，对应的中断程序：
void NMIException(void)
{
if (RCC_GetITStatus(RCC_IT_CSS) != RESET)
{  // HSE、PLL已被禁止(但是PLL设置未变)
… …  // 客户添加相应的系统保护代码处
// 下面为HSE恢复后的预设置代码
RCC_HSEConfig(RCC_HSE_ON);  // 使能HSE
RCC_ITConfig(RCC_IT_HSERDY, ENABLE); // 使能HSE就绪中断
RCC_ITConfig(RCC_IT_PLLRDY, ENABLE); // 使能PLL就绪中断
RCC_ClearITPendingBit(RCC_IT_CSS); // 清除时钟安全系统中断的挂起位
// 至此，一旦HSE时钟恢复，将发生HSERDY中断，在RCC中断处理程序里，
系统时钟可以设置到以前的状态
}
}



PVD中断
当VDD下降到
PVD阀值以下和/或当VDD上升到PVD阀值之上时，根据
外部中断第16线的上升/下降边沿触发设置，就会产生
PVD中断。在中断处理程序中执行紧急关闭任务：将
MCU的寄存器、内存的数据保存起来，同时对外设进行
相应的保护操作。



下面这个借鉴到 FaultAsert里面
#define PDEBUG(fmt, args...) printk( KERN_DEBUG "scull: " fmt, ## args)
 宏定义中的省略号表示一串可变的参数, 这一串参数可用args加以引用.
例
PDEBUG("a=%d, b=%d", a, b);  宏展开   printk( KERN_DEBUG "scull: " "a=%d, b=%d", a, b);



记录学习网页
https://blog.csdn.net/k331922164/article/details/46275247?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control
https://wenku.baidu.com/view/5d1f4e9277232f60dccca13f.html



F4模板 把systick固定改为1ms，看看 stm32f4xx_hal.c 文件里面的有关函数 修改初始化里面的systick的初始化，做成可以自设的，默认设为1Khz！！！

时钟初始化那里 修改 先这么来
//	RCC_OscInitStruct.OscillatorType=RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_LSE;
	RCC_OscInitStruct.OscillatorType=RCC_OSCILLATORTYPE_HSE;

关于CAN部分 再把CSEM最新的和模板的对比一下看看，加上发送中断

